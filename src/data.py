import pandas as pd
import torch
import determined as det

all_labels = ["data_class", "malware_type", "malware_type_family"]


def drop_nonnumeric(
    df: pd.DataFrame, target: str = None, normalize: bool = False
) -> pd.DataFrame:
    """Filter out non-numeric columns from a dataframe.
    Replace NaN with 0 and drop columns with all 0.

    Args:
        df (pd.DataFrame): input dataframe
        target (str, optional): target column. Defaults to None.
        normalize (bool, optional): Option to normalize the data. Defaults to False.

    Returns:
        pd.DataFrame: filtered dataframe
    """
    if target:
        df_target = df[target]
    df_num = df.select_dtypes(include=["number"]).copy()
    df_num = df_num.fillna(0)
    df_num = df_num.loc[:, (df_num != 0).any(axis=0)]

    if normalize:
        df_num = (df_num - df_num.mean()) / df_num.std()

    if target:
        df_num[target] = df_target
    return df_num


class MalwareDataset:
    def __init__(self, df: pd.DataFrame, target: str, normalize: bool = True):
        """Initialize the dataset.
        Separate the target column from the dataframe and convert it to a
        numeric representation.
        Normalize the data if requested.

        Args:
            df (pd.DataFrame): The dataframe containing the data.
            target (str): The label column.
            normalize (bool, optional): Option to normalize the data. Defaults to True.
        """
        self.download_directory = f"./tmp"

        if target in all_labels:
            all_labels.remove(target)

        for label in all_labels:
            if label in df.columns:
                df = df.drop(label, axis=1)

        df_label = df[target]
        df = df.drop(target, axis=1)
        # df = drop_nonnumeric(df)
        # # Pnly keep the fist 10 columns
        # df = df.iloc[:, :6]
        # # Replace NaN with 0
        # df = df.fillna(0)
        # # Drop columns with all 0
        # df = df.loc[:, (df != 0).any(axis=0)]

        self.df = df

        self.target = target
        label_set = df_label.unique()
        self.label_2_int = dict(zip(label_set, range(len(label_set))))
        self.int_2_label = dict(zip(range(len(label_set)), label_set))
        self.df_label = df_label.apply(lambda x: self.label_2_int[x])
        self.n_dims = df.shape[1]
        self.n_classes = len(df_label.unique())
        print(f"n_dims: {self.n_dims}, n_classes: {self.n_classes}")

    def __len__(self):
        return len(self.df)

    def __getitem__(self, idx: int) -> tuple:
        """Iterator implementation.

        Args:
            idx (int): The index of the item to return.

        Returns:
            tuple: Data and label at the given index.
        """
        return self.df.iloc[idx], self.df_label.iloc[idx]

    def get_label(self, idx: int) -> str:
        """Get the label name for the given index.

        Args:
            idx (int): The label index.

        Returns:
            str: The label name.
        """
        return self.int_2_label[idx]

    def get_label_idx(self, label: str) -> int:
        """Get the label index for the given label name.

        Args:
            label (str): The label name.

        Returns:
            int: The label index.
        """
        return self.label_2_int[label]

    def get_dataloader(
        self, batch_size: int, shuffle: bool = True, num_workers: int = 0
    ) -> torch.utils.data.DataLoader:
        """Get a dataloader for the dataset.

        Args:
            batch_size (int): The batch size.
            shuffle (bool, optional): Option to shuffle the data. Defaults to True.
            num_workers (int, optional): Number of workers to use. Defaults to 0.

        Returns:
            torch.utils.data.DataLoader: The dataloader.
        """
        tensor_data = self.df.to_numpy()
        tensor_labels = self.df_label.to_numpy()
        tensor_dataset = torch.utils.data.TensorDataset(
            torch.from_numpy(tensor_data).float(),
            torch.from_numpy(tensor_labels).long(),
        )
        return det.pytorch.DataLoader(
            tensor_dataset,
            batch_size=batch_size,
            shuffle=shuffle,
            num_workers=num_workers,
        )

    def get_dimensions(self) -> tuple:
        """Get the number of dimensions and classes.

        Returns:
            tuple: Number of dimensions and classes.
        """
        return self.n_dims, self.n_classes
